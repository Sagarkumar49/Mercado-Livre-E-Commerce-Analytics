create database  mercado_livre;
select * from orders;
select date(order_purchase_timestamp) from orders;

select round(sum(price),2) as total_revenue from order_items; 
-- Monthly Revenue Growth Rate: For each month, calculate total revenue and month-over-month growth percentage.


WITH monthly_revenue AS (
    SELECT
        DATE_FORMAT(order_purchase_timestamp, '%Y-%m') AS revenue_month,
        ROUND(SUM(price), 2) AS total_revenue
    FROM
        orders o
    JOIN
        order_items oi ON o.order_id = oi.order_id
    GROUP BY
        revenue_month
    ORDER BY
        revenue_month
),
monthly_growth AS (
    SELECT
        revenue_month,
        total_revenue,
        LAG(total_revenue) OVER (ORDER BY revenue_month) AS prev_month_revenue
    FROM
        monthly_revenue
)
SELECT
    revenue_month,
    total_revenue,
    ROUND(
        (total_revenue - prev_month_revenue) / NULLIF(prev_month_revenue, 0) * 100, 2
    ) AS month_over_month_growth_pct
FROM
    monthly_growth;
-- Trailing 3-Month Moving Average of Orders: For each month, calculate the 3-month moving average of the number of orders.

WITH monthly_orders AS (
    SELECT 
        DATE_FORMAT(order_purchase_timestamp, '%Y-%m') AS order_month,
        COUNT(order_id) AS total_orders
    FROM orders
    GROUP BY order_month
),
moving_avg_orders AS (
    SELECT 
        order_month,
        total_orders,
        ROUND(AVG(total_orders) OVER (
            ORDER BY order_month 
            ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ), 2) AS trailing_3_month_avg
    FROM monthly_orders
)
SELECT * FROM moving_avg_orders;

-- for calculating revenue growth percentage

WITH monthly_revenue AS (
    SELECT
        DATE_FORMAT(o.order_purchase_timestamp, '%Y-%m') AS order_month,
        ROUND(SUM(oi.price), 2) AS total_revenue
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY order_month
)
SELECT
    order_month,
    total_revenue,
    LAG(total_revenue) OVER (ORDER BY order_month) AS prev_month_revenue,
    ROUND(
        (total_revenue - LAG(total_revenue) OVER (ORDER BY order_month)) 
        / NULLIF(LAG(total_revenue) OVER (ORDER BY order_month), 0) * 100, 2
    ) AS revenue_growth_pct
FROM monthly_revenue;


-- for claculating order growht percentage

WITH monthly_orders AS (
    SELECT
        DATE_FORMAT(order_purchase_timestamp, '%Y-%m') AS order_month,
        COUNT(order_id) AS total_orders
    FROM orders
    GROUP BY order_month
)
SELECT
    order_month,
    total_orders,
    LAG(total_orders) OVER (ORDER BY order_month) AS prev_month_orders,
    ROUND(
        (total_orders - LAG(total_orders) OVER (ORDER BY order_month)) 
        / NULLIF(LAG(total_orders) OVER (ORDER BY order_month), 0) * 100, 2
    ) AS orders_growth_pct
FROM monthly_orders;


-- Yearly Average Order Value (AOV): Trend Compute average order value (total revenue / total orders) per year.



WITH yearly_data AS (
    SELECT
        YEAR(o.order_purchase_timestamp) AS order_year,
        COUNT(DISTINCT o.order_id) AS total_orders,
        ROUND(SUM(oi.price), 2) AS total_revenue
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY order_year
)
SELECT
    order_year,
    total_orders,
    total_revenue,
    ROUND(total_revenue / total_orders, 2) AS avg_order_value
FROM yearly_data
ORDER BY order_year;


-- Customer Lifetime Value (CLTV) Approximation: Calculate total revenue generated by each customer. Sort top 10 highest lifetime values.



SELECT
    c.customer_unique_id,
    ROUND(SUM(oi.price), 2) AS total_revenue
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY c.customer_unique_id
ORDER BY total_revenue DESC
LIMIT 10;

-- Top Product Categories by Growth: Identify top 5 categories with the highest year-over-year revenue growth. have to check something different from the other syntax


WITH category_yearly_revenue AS (
    SELECT
		pc.product_category_name_english as category_name,
        YEAR(o.order_purchase_timestamp) AS order_year,
        ROUND(SUM(oi.price), 2) AS total_revenue
    FROM order_items oi
    JOIN orders o ON oi.order_id = o.order_id
    JOIN products p ON oi.product_id = p.product_id
    LEFT JOIN product_category pc ON p.product_category_name=p.product_category_name
    WHERE o.order_status = 'delivered'
    GROUP BY category_name, YEAR(o.order_purchase_timestamp)
),
category_growth AS (
    SELECT 
        category_name,
        order_year,
        total_revenue,
        LAG(total_revenue) OVER (PARTITION BY category_name ORDER BY order_year) AS prev_year_revenue,
        ROUND(
            ((total_revenue - LAG(total_revenue) OVER (PARTITION BY category_name ORDER BY order_year)) 
            / LAG(total_revenue) OVER (PARTITION BY category_name ORDER BY order_year)) * 100, 
        2) AS revenue_growth_pct
    FROM category_yearly_revenue
)
SELECT 
	category_name,
    order_year,
    total_revenue,
    prev_year_revenue,
    revenue_growth_pct
FROM category_growth
WHERE prev_year_revenue IS NOT NULL
ORDER BY revenue_growth_pct DESC
LIMIT 5;

-- Top Product Categories by Growth: Identify top 5 categories with the highest year-over-year revenue growth.

WITH category_yearly_revenue AS (
    SELECT 
        pct.product_category_name_english AS category_name,
        YEAR(o.order_purchase_timestamp) AS order_year,
        ROUND(SUM(oi.price), 2) AS total_revenue
    FROM order_items oi
    JOIN orders o ON oi.order_id = o.order_id
    JOIN products p ON oi.product_id = p.product_id
    LEFT JOIN product_category pct ON p.product_category_name = pct.product_category_name
    WHERE o.order_status = 'delivered'
    GROUP BY pct.product_category_name_english, YEAR(o.order_purchase_timestamp)
),
category_growth AS (
    SELECT 
        category_name,
        order_year,
        total_revenue,
        LAG(total_revenue) OVER (PARTITION BY category_name ORDER BY order_year) AS prev_year_revenue,
        ROUND(
            ((total_revenue - LAG(total_revenue) OVER (PARTITION BY category_name ORDER BY order_year)) 
            / LAG(total_revenue) OVER (PARTITION BY category_name ORDER BY order_year)) * 100, 
        2) AS revenue_growth_pct
    FROM category_yearly_revenue
)
SELECT 
    category_name,
    order_year,
    total_revenue,
    prev_year_revenue,
    revenue_growth_pct
FROM category_growth
WHERE prev_year_revenue IS NOT NULL
ORDER BY revenue_growth_pct DESC
LIMIT 5;


-- Seller Fulfillment Efficiency: For each seller, calculate the average difference between estimated and actual delivery date. Highlight the most efficient ones.


SELECT 
    oi.seller_id,
    ROUND(AVG(DATEDIFF(o.order_estimated_delivery_date, o.order_delivered_customer_date)), 2) AS avg_delivery_diff_days
FROM 
    orders o
JOIN 
    order_items oi ON o.order_id = oi.order_id
WHERE 
    o.order_delivered_customer_date IS NOT NULL
    AND o.order_estimated_delivery_date IS NOT NULL
GROUP BY 
    oi.seller_id
ORDER BY 
    avg_delivery_diff_days DESC
LIMIT 10;



SELECT 
    oi.seller_id,
    ROUND(AVG(DATEDIFF(o.order_delivered_customer_date, o.order_estimated_delivery_date)), 2) AS avg_delivery_delay_days
FROM 
    orders o
JOIN 
    order_items oi ON o.order_id = oi.order_id
WHERE 
    o.order_delivered_customer_date IS NOT NULL
    AND o.order_estimated_delivery_date IS NOT NULL
GROUP BY 
    oi.seller_id
ORDER BY 
    avg_delivery_delay_days ASC
LIMIT 10;



SELECT 
    oi.seller_id,
    ROUND(AVG(DATEDIFF(o.order_delivered_customer_date, o.order_estimated_delivery_date)), 2) AS avg_delivery_delay_days,
    CASE 
        WHEN ROUND(AVG(DATEDIFF(o.order_delivered_customer_date, o.order_estimated_delivery_date)), 2) < 0 THEN 'Early Delivery'
        WHEN ROUND(AVG(DATEDIFF(o.order_delivered_customer_date, o.order_estimated_delivery_date)), 2) = 0 THEN 'On Time'
        ELSE 'Late Delivery'
    END AS delivery_status
FROM 
    orders o
JOIN 
    order_items oi ON o.order_id = oi.order_id
WHERE 
    o.order_delivered_customer_date IS NOT NULL
    AND o.order_estimated_delivery_date IS NOT NULL
GROUP BY 
    oi.seller_id
ORDER BY 
    avg_delivery_delay_days ASC
LIMIT 10;


SELECT 
    seller_id,
    ROUND(AVG(DATEDIFF(order_estimated_delivery_date, order_delivered_customer_date)), 2) AS flipped_avg_diff
FROM 
    orders o
JOIN 
    order_items oi ON o.order_id = oi.order_id
WHERE 
    order_delivered_customer_date IS NOT NULL 
    AND order_estimated_delivery_date IS NOT NULL
GROUP BY 
    seller_id
ORDER BY 
    flipped_avg_diff DESC
    limit 10;




-- Time to First Purchase: For customers with multiple orders, calculate the average number of days between account creation and first purchase.




WITH customer_first_last AS (
    SELECT 
        c.customer_unique_id,
        MIN(o.order_purchase_timestamp) AS first_purchase,
        MAX(o.order_purchase_timestamp) AS last_purchase,
        COUNT(o.order_id) AS total_orders
    FROM orders o
    join customers c 
    on c.customer_id=o.customer_id
    GROUP BY customer_unique_id
    HAVING COUNT(order_id) > 1
),
days_diff AS (
    SELECT 
        customer_unique_id,
        DATEDIFF(first_purchase, last_purchase) AS days_to_first_purchase
    FROM customer_first_last
)
SELECT 
    ROUND(AVG(ABS(days_to_first_purchase)), 2) AS avg_days_to_first_purchase
FROM days_diff;






WITH customer_orders_ranked AS (
    SELECT 
        customer_id,
        order_purchase_timestamp,
        ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_purchase_timestamp) AS purchase_rank
    FROM orders
),
first_second_purchases AS (
    SELECT 
        customer_id,
        MAX(CASE WHEN purchase_rank = 1 THEN order_purchase_timestamp END) AS first_purchase,
        MAX(CASE WHEN purchase_rank = 2 THEN order_purchase_timestamp END) AS second_purchase
    FROM customer_orders_ranked
    GROUP BY customer_id
),
valid_customers AS (
    SELECT 
        customer_id,
        DATEDIFF(second_purchase, first_purchase) AS days_to_first_purchase
    FROM first_second_purchases
    WHERE second_purchase IS NOT NULL
)
SELECT 
    ROUND(AVG(days_to_first_purchase), 2) AS avg_days_to_first_purchase
FROM valid_customers;





SELECT 
    customer_id,
    COUNT(order_id) AS total_orders
FROM orders
GROUP BY customer_id
HAVING COUNT(order_id) > 1
ORDER BY total_orders DESC;





WITH customer_orders AS (
    SELECT 
        c.customer_unique_id,
        o.order_purchase_timestamp,
        ROW_NUMBER() OVER (PARTITION BY c.customer_unique_id ORDER BY o.order_purchase_timestamp ASC) AS order_rank
    FROM
        orders o
    JOIN
        customers c
    ON
        o.customer_id = c.customer_id
)

SELECT
    first.customer_unique_id,
    DATEDIFF(DAY, first.order_purchase_timestamp, second.order_purchase_timestamp) AS time_to_second_purchase_days
FROM
    customer_orders first
JOIN
    customer_orders second
ON
    first.customer_unique_id = second.customer_unique_id
    AND first.order_rank = 1
    AND second.order_rank = 2





-- Review Sentiment vs Delivery Time: Compare average delivery days for orders with 1–2 stars vs 4–5 stars.

SELECT 
  CASE 
    WHEN r.review_score IN (1, 2) THEN 'Low (1-2 Stars)'
    WHEN r.review_score IN (4, 5) THEN 'High (4-5 Stars)'
  END AS review_category,
  ROUND(AVG(DATEDIFF(o.order_delivered_customer_date, o.order_purchase_timestamp)), 2) AS avg_delivery_days
FROM 
  order_reviews r
JOIN 
  orders o ON r.order_id = o.order_id
WHERE 
  r.review_score IN (1, 2, 4, 5)
  AND o.order_delivered_customer_date IS NOT NULL
GROUP BY 
  review_category;
  
  
  
  
 -- Payment Method Impact: Analyze which payment methods lead to the highest average review scores. 
  
  SELECT 
  p.payment_type,
  ROUND(AVG(r.review_score), 2) AS avg_review_score
FROM 
  order_payments p
JOIN 
  order_reviews r ON p.order_id = r.order_id
GROUP BY 
  p.payment_type
ORDER BY 
  avg_review_score DESC;


-- State-Wise Revenue Per Customer: For each state, compute average revenue per customer.



WITH customer_revenue AS (
  SELECT 
    o.customer_id,
    SUM(oi.price) AS total_revenue
  FROM 
    orders o
  JOIN 
    order_items oi ON o.order_id = oi.order_id
  GROUP BY 
    o.customer_id
)

SELECT 
  c.customer_state,
  ROUND(AVG(cr.total_revenue), 2) AS avg_revenue_per_customer
FROM 
  customer_revenue cr
JOIN 
  customers c ON cr.customer_id = c.customer_id
GROUP BY 
  c.customer_state
ORDER BY 
  avg_revenue_per_customer DESC;


-- Repeat Purchase Analysis: What percentage of customers placed more than one order?


WITH customer_order_counts AS (
    SELECT 
        customer_id,
        COUNT(order_id) AS order_count
    FROM orders
    GROUP BY customer_id
)

SELECT 
    ROUND(
        100.0 * COUNT(CASE WHEN order_count > 1 THEN 1 END) 
        / COUNT(*), 
        2
    ) AS repeat_purchase_percentage
FROM customer_order_counts;





with customer_count as 
(
SELECT 
    customers.customer_unique_id,
    COUNT(orders.order_id) AS order_count
FROM
    customers
        JOIN
    orders ON customers.customer_id = orders.customer_id
GROUP BY customers.customer_unique_id)

SELECT 
    ROUND(100 * COUNT(CASE
                WHEN order_count > 1 THEN 1
            END) / COUNT(*),
            2) AS repeat_purchase_pct
FROM
    customer_count
;




SELECT 
    COUNT(*) AS repeat_customers
FROM (
    SELECT customer_id
    FROM orders
    GROUP BY customer_id
    HAVING COUNT(order_id) > 1
) AS repeat_customer_table;






-- Top SKUs by Profit Contribution: Calculate profit per SKU (price - freight + volume assumption), then list top 10 contributors.


SELECT 
    oi.product_id,
    ROUND(SUM(oi.price - oi.freight_value + 
        (p.product_length_cm * p.product_height_cm * p.product_width_cm)), 2) AS total_profit
FROM order_items oi
JOIN products p 
    ON oi.product_id = p.product_id
GROUP BY oi.product_id
ORDER BY total_profit DESC
LIMIT 10;




SELECT 
    oi.product_id,
    ROUND(SUM(oi.price - oi.freight_value + 
        (p.product_length_cm * p.product_height_cm * p.product_width_cm) / 1000), 2) AS total_profit
FROM order_items oi
JOIN products p 
    ON oi.product_id = p.product_id
GROUP BY oi.product_id
ORDER BY total_profit DESC
LIMIT 10;




-- Step 1: Define both profit methods
WITH unscaled_profit AS (
    SELECT 
        oi.product_id,
        ROUND(SUM(oi.price - oi.freight_value + 
            (p.product_length_cm * p.product_height_cm * p.product_width_cm)), 2) AS total_profit_unscaled
    FROM order_items oi
    JOIN products p ON oi.product_id = p.product_id
    GROUP BY oi.product_id
),
scaled_profit AS (
    SELECT 
        oi.product_id,
        ROUND(SUM(oi.price - oi.freight_value + 
            (p.product_length_cm * p.product_height_cm * p.product_width_cm) / 1000), 2) AS total_profit_scaled
    FROM order_items oi
    JOIN products p ON oi.product_id = p.product_id
    GROUP BY oi.product_id
)

-- Step 2: Join both and rank
SELECT 
    sp.product_id,
    sp.total_profit_scaled,
    usp.total_profit_unscaled
FROM scaled_profit sp
JOIN unscaled_profit usp ON sp.product_id = usp.product_id
ORDER BY sp.total_profit_scaled DESC
LIMIT 10;





SELECT customer_id, MIN(order_purchase_timestamp) AS first_purchase, 
       MAX(order_purchase_timestamp) AS last_purchase
FROM orders
GROUP BY customer_id
HAVING COUNT(order_id) > 1;
WITH customer_order_count AS (
    SELECT customer_id, COUNT(order_id) AS total_orders
    FROM orders
    GROUP BY customer_id
)
SELECT 
    ROUND(100.0 * COUNT(CASE WHEN total_orders > 1 THEN 1 END) / COUNT(*), 2) AS repeat_purchase_percent
FROM customer_order_count;

